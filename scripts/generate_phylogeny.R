suppressPackageStartupMessages(library("tidytree"))
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("castor"))
suppressPackageStartupMessages(library("phytools"))
suppressPackageStartupMessages(library("treeio"))
suppressPackageStartupMessages(library("phangorn"))


change_label_to_node <- function(phylo_file, tip_label_vector){
    # @description: takes in a character vector of tip labels, returns the corresponding node numbers in `phylo_file`.
    #
    # @param phylo_file: a phylo object containing tip labels of interest.
    # @param tip_label_vector: a character vector containing tip labels of interest.
    #
    # @returns: a numeric vector containing node IDs for tip labels.

    phylo_file_tbl <- tibble::as_tibble(phylo_file)
    ind <- which(phylo_file_tbl$label %in% tip_label_vector)
    nodes_vector <- phylo_file_tbl$node[ind]
    return(nodes_vector)
}


determine_target_taxrank_taxid <- function(lineage_df_row, ref_phylo_paramlist){
    # @description: determines the lowest taxonomic rank possible that a query taxon can be mapped to a reference
    # phylogeny and the corresponding taxonomy ID for the query taxon's ancestor node at that taxonomic rank.
    #
    # @param lineage_df_row: a lineage summary dataframe of shape [1,] for a query taxon.
    # @param ref_phylo_paramlist: a list containing reference phylogeny-related objects on which the determination
    # of target taxonomic rank and taxonomy ID is based.
    #
    # @returns: a list in which [["taxonomic_rank"]] describes taxonomic rank a query taxon can be mapped, otherwise NA;
    # and [["taxonomy_id"]] describes the taxonomy ID at that particular rank for the query taxon, otherwise NA.

    taxrank_cols_vector <- ref_phylo_paramlist[["taxrank_cols"]]
    taxids_by_ranks_list <- ref_phylo_paramlist[["taxids_by_ranks"]]

    no_names <- is.null(names(taxrank_cols_vector)) | is.null(names(taxids_by_ranks_list))
    different_names <- !identical(names(taxrank_cols_vector), names(taxids_by_ranks_list))
    if (no_names | different_names) {
        stop("Check names for `taxrank_cols_vector` and `taxids_by_ranks_list`!")
    }

    output_list <- list()
    tax_rank <- NA
    tax_id <- NA
    for (i_taxrank in names(taxrank_cols_vector)) {
        colname <- taxrank_cols_vector[[i_taxrank]]
        # use `as.numeric` to revert coercion of numeric objects into characters when applied to `apply` function
        if (as.numeric(lineage_df_row[[colname]]) %in% taxids_by_ranks_list[[i_taxrank]]) {
            tax_rank <- i_taxrank
            tax_id <- lineage_df_row[[colname]]
            break
        }
    }
    output_list[["taxonomic_rank"]] <- tax_rank
    output_list[["taxonomy_id"]] <- tax_id
    return(output_list)
}


determine_target_node_tips <- function(ref_phylo_paramlist, taxrank_taxid_list, maximum_tips, outlier_labels_vector){
    # @description: determines the most recent common ancestor node and qualified children tips as references for a
    # query taxon.
    #
    # @param ref_phylo_paramlist: a list containing reference phylogeny-related objects on which the determination
    # of target ancestor node and qualified children tips is based.
    # @param taxrank_taxid_list: the output list generated by calling `determine_target_taxrank_taxid` on the same
    # query taxon and reference phylogeny.
    # @param maximum_tips: number of maximum tips for downstream computation, used to avoid memory crash.
    # @param outlier_labels_vector: outlier tip labels to exclude, default is NULL.
    #
    # @returns: a list in which [["node"]] describes target ancestor node number; and [["tips"]] contains a vector of
    # children tip labels which share ancestry with query taxon.

    ref_phylo <- ref_phylo_paramlist[["phylo"]]
    complete_ref_lineage_df <- ref_phylo_paramlist[["complete_lineage"]]
    phylo_lineage_tbl <- ref_phylo_paramlist[["phylo_tbl_lineage"]]
    taxrank_cols_vector <- ref_phylo_paramlist[["taxrank_cols"]]
    tax_rank <- taxrank_taxid_list[["taxonomic_rank"]]
    tax_id <- taxrank_taxid_list[["taxonomy_id"]]

    output_list <- list()
    taxcolumn <- taxrank_cols_vector[[tax_rank]]
    reference_tips_vector <- complete_ref_lineage_df %>% dplyr::filter(.data[[taxcolumn]] == tax_id) %>%
        dplyr::pull(.data[["TipOnPhylo"]])
    reference_tips_vector <- unique(reference_tips_vector[!is.na(reference_tips_vector)])
    if (length(reference_tips_vector) > maximum_tips) {
        reference_tips_vector <- sample(reference_tips_vector, size = maximum_tips, replace = FALSE)
    }
    reference_tips_vector <- setdiff(reference_tips_vector, outlier_labels_vector)
    nodes_vector <- phylo_lineage_tbl %>% dplyr::filter(.data[["label"]] %in% reference_tips_vector) %>%
        pull(.data[["node"]])
    node <- ifelse(length(nodes_vector) > 1,
                   ape::getMRCA(ref_phylo, nodes_vector),
                   tidytree::MRCA(ref_phylo,nodes_vector))
    output_list[["node"]] <- node
    output_list[["tips"]] <- reference_tips_vector
    return(output_list)
}


compute_insertion_stats <- function(ref_phylo, node_tip_list = NULL){
    # @description: returns necessary information needed to insert a query taxon onto the reference phylogeny.
    #
    # @param ref_phylo: reference phylogeny.
    # @param node_tip_list: a list with elements [["node"]] and [["tips"]] and is the result of calling function
    # `determine_target_node_tips`. Default NULL does the computation including all tip labels of `ref_phylo`.
    #
    # @returns: a list in which [["subtree"]] contains a tree object with only tip labels specified in `node_tip_list`;
    # [["matrix"]] contains a distance matrix representing all pairwise distances of tips in the subtree; and
    # [["length"]] is the calculated branch length to insert a taxon based on the distance matrix.

    tryCatch(
        {
        if (is.null(node_tip_list)) {
            node_number <- castor::find_root(ref_phylo)
            tip_label_vector <- ref_phylo$tip.label
        } else {
            node_number <- node_tip_list[["node"]]
            tip_label_vector <- node_tip_list[["tips"]]
        }

        output_list <- list()
        if (treeio::isTip(ref_phylo, node_number)) {
            output_list[["subtree"]] <- NULL
            output_list[["matrix"]] <- matrix()
            output_list[["length"]] <- 0
        } else {
            subtree <- castor::get_subtree_with_tips(ref_phylo, tip_label_vector)$subtree
            root_number <- castor::find_root(subtree)
            node_vector <- change_label_to_node(subtree, tip_label_vector)
            distance_matrix <- castor::get_all_pairwise_distances(subtree)
            rownames(distance_matrix) <- as.character(1:dim(distance_matrix)[1])
            colnames(distance_matrix) <- as.character(1:dim(distance_matrix)[2])
            rownames(distance_matrix)[node_vector] <- tip_label_vector
            colnames(distance_matrix)[node_vector] <- tip_label_vector
            distance_vector <- NULL
            for (i_node in node_vector) {
                distance_vector <- c(distance_vector, distance_matrix[root_number, i_node])
            }
            output_list[["subtree"]] <- subtree
            output_list[["matrix"]] <- distance_matrix
            output_list[["length"]] <- mean(distance_vector)
        }
        return(output_list)
        },
        error = function(err){
            print(err)
            output_error <- list()
            output_error[["subtree"]] <- NULL
            output_error[["matrix"]] <- matrix()
            output_error[["length"]] <- NA
            return(output_error)
        }
    )
}


find_outliers_two_refs <- function(ref_phylo_paramlist, node_tip_list){
    # @description: determine the outlier tip label when there are only two reference tips identified in the reference
    # phylogeny. This is done by first comparing the lowest taxonomic rank shared with close neighboring tips, and by
    # the average distance calculated based on these neighboring tips.
    #
    # @param ref_phylo_paramlist: a list containing reference phylogeny-related objects on which the determination
    # of potential outlier tip is based.
    # @param node_tip_list: a list with elements [["node"]] and [["tips"]] and is the result of calling function
    # `determine_target_node_tips`.
    #
    # @returns: label of the outlier tip.

    ref_phylo <- ref_phylo_paramlist[["phylo"]]
    phylo_lineage_tbl <- ref_phylo_paramlist[["phylo_tbl_lineage"]]
    taxrank_cols_vector <- ref_phylo_paramlist[["taxrank_cols"]]
    tip_label_vector <- node_tip_list[["tips"]]

    tryCatch(
        {
        mapping_taxrank <- list()
        mapping_distances <- list()
        ordered_taxranks_vector <- names(taxrank_cols_vector)
        temp_lineage_df <- phylo_lineage_tbl %>% dplyr::filter(.data[["label"]] %in% tip_label_vector)
        for (i in seq_along(tip_label_vector)) {
            tip_label <- tip_label_vector[i]
            # check lowest taxonomic rank shared with close neighboring tips
            subtree <- treeio::tree_subset(ref_phylo, tip_label, levels_back = 2)
            subtree_tip_labels <- subtree$tip.label
            subtree_lineage_table <- phylo_lineage_tbl %>%
                dplyr::filter(.data[["label"]] %in% subtree_tip_labels[!(subtree_tip_labels %in% tip_label_vector)])
            temp_taxids_by_ranks_list <- list()
            for (i_taxrank in ordered_taxranks_vector) {
                temp_colname <- taxrank_cols_vector[[i_taxrank]]
                temp_unique_ids <- unique(subtree_lineage_table[[temp_colname]])
                temp_taxids_by_ranks_list[[i_taxrank]] <- temp_unique_ids[!is.na(temp_unique_ids)]
            }
            temp_ref_phylo_paramlist <- list("taxrank_cols" = taxrank_cols_vector,
                                             "taxids_by_ranks" = temp_taxids_by_ranks_list)
            temp_mapping_result <- determine_target_taxrank_taxid(temp_lineage_df[i, ], temp_ref_phylo_paramlist)
            mapping_taxrank[[tip_label]] <- which(ordered_taxranks_vector == temp_mapping_result[["taxonomic_rank"]])
            mapping_distances[[tip_label]] <- compute_insertion_stats(subtree)[["length"]]
        }
        tip_with_distant_neighbors <- names(mapping_taxrank)[mapping_taxrank == max(unlist(mapping_taxrank))]
        if (length(tip_with_distant_neighbors) == 1) {
            outlier_tip <- tip_with_distant_neighbors
        } else {
            outlier_tip <- names(mapping_distances)[mapping_distances == max(unlist(mapping_distances))][1]
        }
        return(outlier_tip)
        },
        error = function(err){
            print(err)
            outlier_tip <- tip_label_vector[1]
            return(outlier_tip)
        }
    )
}


find_outliers_causing_NAs <- function(ref_phylo_paramlist, node_tip_list, count_limit_int = 10){
    # @description: determine extreme outlier tip labels which lead to a large subtree and distance matrix that
    # cause vector momory exhausted error.
    #
    # @param ref_phylo_paramlist: a list containing reference phylogeny-related objects on which the determination
    # of potential outlier tips is based.
    # @para node_tip_list: a list with elements [["node"]] and [["tips"]] and is the result of calling function
    # `determine_target_node_tips`.
    # @param count_limit_int: The number of consecutive times the distance can be calculated successfully after
    # removal of potential outlier tips, after which iterative test stops.
    #
    # @returns: a vector of outlier tip labels.

    ref_phylo <- ref_phylo_paramlist[["phylo"]]
    subtreeNA_root_int <- node_tip_list[["node"]]
    tip_label_vector <- node_tip_list[["tips"]]

    middle_ind <- floor((length(tip_label_vector) + 1) / 2)
    middle_tip_label <- tip_label_vector[middle_ind]
    tip_labels_list <- list(forward = tip_label_vector[1:(middle_ind - 1)],
                            reverse = rev(tip_label_vector[(middle_ind + 1):length(tip_label_vector)]))
    outlier_tips <- NULL
    for (sublist in tip_labels_list) {
        consecutive_success <- 0
        for (tip_label in sublist) {
            if (consecutive_success >= count_limit_int) {
                break
            } else {
                temp_node <- ape::getMRCA(ref_phylo, c(tip_label, middle_tip_label))
                if (temp_node == subtreeNA_root_int) {
                    # no need to further test if the MRCA node is the same as the one causing error
                    outlier_tips <- c(outlier_tips, tip_label)
                } else {
                    temp_node_transformed <- temp_node - length(ref_phylo$tip.label)
                    subtree <- castor::get_subtree_at_node(ref_phylo, temp_node_transformed)$subtree
                    temp_tip_labels <- intersect(subtree$tip.label, tip_label_vector)
                    subtree <- castor::get_subtree_with_tips(ref_phylo, temp_tip_labels)$subtree
                    temp_branch_length <- compute_insertion_stats(subtree)[["length"]]
                    if (is.na(temp_branch_length)) {
                        outlier_tips <- c(outlier_tips, tip_label)
                    } else {
                        consecutive_success <- consecutive_success + 1
                    }
                }
            }
        }
    }
    return(outlier_tips)
}


detect_outliers_main <- function(ref_phylo_paramlist, taxrank_taxid_list, node_tip_list,
                                 insertion_stats_list, maximum_tips, sd_threshold_list){
    # @description: determines all types of outlier tips to exclude from calculation of insertion statistics.

    # @param ref_phylo_paramlist: a list containing reference phylogeny-related objects on which the determination
    # of potential outlier tips is based.
    # @param taxrank_taxid_list: a list with elements [["taxonomic_rank"]] and [["taxonomy_id""]]. The returned
    # value of calling function `determine_target_taxrank_taxid`.
    # @para node_tip_list: a list with elements [["node"]] and [["tips"]]. The returned values of calling function
    # `determine_target_node_tips`.
    # @param insertion_stats_list: a list with elements [["subtree"]], [["matrix"]], and [["length"]]. The returned
    #  value of calling function `compute_insertion_stats`.
    # @param maximum_tips: number of maximum tips for downstream computation, used to avoid memory crash.
    # @param sd_threshold_list: thresholds of numbers of standard deviation to define potential outliers.
    #
    # @returns: a vector of outlier tip labels.

    outlier_names <- c("NAs", "two refs", "species", "species group", "genus and above")
    outliers_list <- list()
    outliers_list[outlier_names] <- list(NULL)

    ref_phylo <- ref_phylo_paramlist[["phylo"]]
    tax_rank <- taxrank_taxid_list[["taxonomic_rank"]]
    branch_length <- insertion_stats_list[["length"]]
    n_sd_species <- sd_threshold_list[["species"]]
    n_sd_species_group <- sd_threshold_list[["species group"]]
    n_sd_genus_and_above <- sd_threshold_list[["genus and above"]]
    n_outlier_two <- sd_threshold_list[["two refs"]]

    # if the calculated branch length is NA, need to exclude extreme outliers first in order to proceed with valid
    # distance matrices.
    if (is.na(branch_length)) {
        outliers_list[["NAs"]] <- find_outliers_causing_NAs(ref_phylo_paramlist, node_tip_list)
        node_tip_list <- determine_target_node_tips(ref_phylo_paramlist, taxrank_taxid_list, maximum_tips,
                                                    outliers_list[["NAs"]])
        insertion_stats_list <- compute_insertion_stats(ref_phylo, node_tip_list)
    }
    tip_label_vector <- node_tip_list[["tips"]]
    subtree <- insertion_stats_list[["subtree"]]
    dist_matrix <- insertion_stats_list[["matrix"]]

    if (length(tip_label_vector) == 1) {
        invisible() # do nothing if there's only one reference tip
    } else if (length(tip_label_vector) == 2) {
        temp_node_vector_original <- change_label_to_node(ref_phylo, tip_label_vector)
        val_subtree <- max(castor::get_all_distances_to_root(subtree))
        val_parent_tree <- max(castor::get_all_distances_to_root(ref_phylo)[temp_node_vector_original])
        if (val_subtree / val_parent_tree >= n_outlier_two) {
            outlier_name <- find_outliers_two_refs(ref_phylo_paramlist, node_tip_list)
            outliers_list[["two refs"]] <- c(outliers_list[["two refs"]], outlier_name)
        }
    } else {
        dist_df <- as.data.frame(dist_matrix)[tip_label_vector, tip_label_vector]
        dist_df <- dist_df %>% dplyr::mutate(mean_val = rowSums(dist_df) / (length(tip_label_vector) - 1))
        mean_dist <- mean(dist_df[["mean_val"]])
        sd_dist <- sd(dist_df[["mean_val"]])
        for (name in rownames(dist_df)) {
            if ((tax_rank == "species") & (dist_df[[name, "mean_val"]] > (mean_dist + n_sd_species * sd_dist))) {
                outliers_list[["species"]] <- c(outliers_list[["species"]], name)
            } else if ((tax_rank == "species group") &
                       (dist_df[name,"mean_val"] > (mean_dist + n_sd_species_group * sd_dist))) {
                outliers_list[["species group"]] <- c(outliers_list[["species group"]], name)
            } else if (dist_df[name,"mean_val"] > (mean_dist + n_sd_genus_and_above * sd_dist)) {
                outliers_list[["genus and above"]] <- c(outliers_list[["genus and above"]], name)
            }
        }
    }
    return(outliers_list)
}


insert_tips <- function(lineage_df, ref_phylo_paramlist, sd_threshold_list, maximum_tips = 5000){
    # @description: insert taxa onto the reference phylogeny
    #
    # @param lineage_df: a lineage summary dataframe for a query taxa.
    # @param ref_phylo_paramlist: a list containing reference phylogeny-related objects to which the query taxa
    # are appended.
    # @param sd_threshold_list: thresholds of numbers of standard deviation to define potential outliers.
    # @param maximum_tips: number of maximum tips for downstream computation, used to avoid memory crash.
    #
    # @returns: a dataframe to guide insertion of query taxa.

    ref_phylo <- ref_phylo_paramlist[["phylo"]]
    summary_df <- tibble(TaxID = numeric(), ScientificName = character(), Level = character(), Node = numeric(),
                         BranchLength = double(), NRefTips = numeric())
    ave_proc_time <- 0
    start_time <- Sys.time()
    for (i in seq_len(nrow(lineage_df))) {
        cat(sprintf("\r>>> The %4sth taxon being processed. Progress: %6.2f%%; ETR: %5.2f min. <<<", as.character(i),
                    round(i * 100 / nrow(lineage_df), 2), round(((nrow(lineage_df) - i)) * ave_proc_time, 2)))
        i_query_taxid <- lineage_df[[i, "TaxID"]]
        i_query_name <- lineage_df[[i, "ScientificName"]]
        i_target_taxrank_taxid_result <- determine_target_taxrank_taxid(lineage_df[i,], ref_phylo_paramlist)
        i_target_taxrank <- i_target_taxrank_taxid_result[["taxonomic_rank"]]
        i_target_node_tips_result <- determine_target_node_tips(ref_phylo_paramlist, i_target_taxrank_taxid_result,
                                                                maximum_tips, NULL)
        i_insertion_stats <- compute_insertion_stats(ref_phylo, i_target_node_tips_result)
        i_outliers <- unlist(detect_outliers_main(ref_phylo_paramlist, i_target_taxrank_taxid_result,
                                                  i_target_node_tips_result, i_insertion_stats, maximum_tips,
                                                  sd_threshold_list))
        i_target_node_tips_result_updated <- determine_target_node_tips(ref_phylo_paramlist,
                                                                        i_target_taxrank_taxid_result,
                                                                        maximum_tips, i_outliers)
        i_target_node_updated <- i_target_node_tips_result_updated[["node"]]
        i_target_tips_updated <- i_target_node_tips_result_updated[["tips"]]
        i_insertion_stats_updated <- compute_insertion_stats(ref_phylo, i_target_node_tips_result_updated)
        i_branch_len_updated <- i_insertion_stats_updated[["length"]]
        record <- tibble(TaxID = i_query_taxid, ScientificName = i_query_name, Level = i_target_taxrank,
                         Node = i_target_node_updated, BranchLength = i_branch_len_updated,
                         NRefTips = length(i_target_tips_updated))
        summary_df <- rbind(summary_df, record)
        current_time <- Sys.time()
        elapsed_time <- current_time - start_time
        ave_proc_time <- as.numeric(elapsed_time, units = "mins") / i
  }
    cat("\n")
    return(summary_df)
}

report_omitted_taxa <- function(unmapped_ids, superkingdom_ids, lineage_df){
  # @description: report any query taxon that cannot be mapped to the final phylogeny and write to the note file.
  #
  # @param unmapped_ids: a vector of query taxonomy IDs that cannot be mapped to current reference phylogeny.
  # @param superkingdom_ids: a vector of query taxonomy IDs that can only be mapped at the superkingdom level.
  # @param lineage_df: lineary summary data frame for query taxa.
  #
  # @returns: character strings to write to note.txt file.

    note_str <- ""
    if (length(unmapped_ids) == 0 & length(superkingdom_ids) == 0) {
        cat("All taxa can be mapped at taxonomic ranks lower than superkingdom.\n")
        note_str <- paste0(note_str, "\nAll taxa can be mapped at taxonomic ranks lower than superkingdom.\n")
    } else {
        if (length(unmapped_ids) > 0) {
            note_str <- paste0(note_str, "\nThe following taxa from user input cannot be mapped to current ",
                               "phylogeny:\n")
            for (taxonomy_id in unmapped_ids) {
                ind <- which(lineage_df[["TaxID"]] == taxonomy_id)
                scientific_name <- lineage_df[[ind, "ScientificName"]]
                note_str <- paste0(note_str, taxonomy_id, "\t", scientific_name, "\n")
            }
        }
        if (length(superkingdom_ids) > 0) {
            note_str <- paste0(note_str, "\nThe following taxa from user input can only be mapped at the ",
                               "superkingdom level and are not inserted into the phylogeny:\n")
            for (taxonomy_id in superkingdom_ids) {
                ind <- which(lineage_df[["TaxID"]] == taxonomy_id)
                scientific_name <- lineage_df[[ind, "ScientificName"]]
                note_str <- paste0(note_str, taxonomy_id, "\t", scientific_name, "\n")
            }
        }
    }
    return(note_str)
}


args <- commandArgs(trailingOnly = TRUE)
input_reference_dir <- args[1]
output_dir <- args[2]
n_sd_species <- as.numeric(args[3])
n_sd_species_group <- as.numeric(args[4])
n_sd_genus_and_above <- as.numeric(args[5])
n_ref_two <- as.numeric(args[6])

cat("Loading and processing input files...\n")
if (!dir.exists(output_dir)) {dir.create(output_dir)}
reference_files <- list.files(input_reference_dir)
phylo_file <- reference_files[startsWith(reference_files, "GTDB")][1]
phylo_file_path <- file.path(input_reference_dir, phylo_file)
phylo_lineage_file_path <- file.path(output_dir, "tip_lineage.csv")
user_lineage_file_path <- file.path(output_dir, "user_lineage.csv")
summary_file_path <- file.path(output_dir, "insertion_summary.csv")
names_tree_path <- file.path(output_dir, "scientific_names.tree")
taxids_tree_path <- file.path(output_dir, "taxIDs.tree")
output_note_path <- file.path(output_dir, "note.txt")

phylo_tree <- ape::read.tree(phylo_file_path)
phylo_tbl <- tibble::as_tibble(phylo_tree)
phylo_lineage_df <- read.csv(phylo_lineage_file_path)
user_lineage_df <- read.csv(user_lineage_file_path)
phylo_with_lineage_tbl <- dplyr::left_join(phylo_tbl, phylo_lineage_df, by = c("label" = "TipLabel"))

taxids_by_ranks_phylo <- list()
ordered_ranks <- c("species", "species group", "genus", "family", "order", "class", "phylum", "superkingdom")
rank_columns <- setNames(c("TaxSpecies", "TaxSpeciesGroup", "TaxGenus", "TaxFamily", "TaxOrder", "TaxClass",
                           "TaxPhylum", "TaxSuperKingdom"),
                         ordered_ranks)
for (taxonomic_rank in ordered_ranks) {
    temp_colname <- rank_columns[[taxonomic_rank]]
    unique_ids <- unique(phylo_lineage_df[[temp_colname]])
    taxids_by_ranks_phylo[[taxonomic_rank]] <- unique_ids[!is.na(unique_ids)]
}

main_ref_phylo_paramlist <- list("phylo" = phylo_tree,
                                 "complete_lineage" = phylo_lineage_df,
                                 "phylo_tbl_lineage" = phylo_with_lineage_tbl,
                                 "taxrank_cols" = rank_columns,
                                 "taxids_by_ranks" = taxids_by_ranks_phylo)
main_sd_threshold_list <- list("species" = n_sd_species,
                               "species group" = n_sd_species_group,
                               "genus and above" = n_sd_genus_and_above,
                               "two refs" = n_ref_two)

cat("Checking if any taxa from user input cannot be mapped or can only be mapped at the superkingdom level:\n")
user_mapping <- sapply(apply(user_lineage_df, MARGIN = 1, determine_target_taxrank_taxid, main_ref_phylo_paramlist),
                       function(x) {x[["taxonomic_rank"]]})
user_na <- user_lineage_df[which(is.na(user_mapping)), "TaxID"]
user_superkingdom <- user_lineage_df[which(user_mapping == "superkingdom"), "TaxID"]
note_str <- report_omitted_taxa(user_na, user_superkingdom, user_lineage_df)
user_lineage_df <- user_lineage_df %>% dplyr::filter(!.data[["TaxID"]] %in% c(user_na, user_superkingdom))
cat("\n")


cat("Mapping taxa from the user input...\n")
summary_table <- insert_tips(user_lineage_df, main_ref_phylo_paramlist, main_sd_threshold_list, 5000)
cat("Process completed!\n\n")


cat("Generating output files...\n")
names_tree <- add.tips(phylo_tree, tips = summary_table$ScientificName, where = summary_table$Node,
                       edge.length = summary_table$BranchLength)
names_tree <- ape::drop.tip(names_tree, phylo_tree$tip.label)
taxids_tree <- names_tree
for (ind in seq_along(taxids_tree$tip.label)) {
  label <- taxids_tree$tip.label[ind]
  summary_table_ind <- which(summary_table$ScientificName == label)
  taxid <- summary_table$TaxID[summary_table_ind]
  taxids_tree$tip.label[ind] <- taxid
}

output_summary_table <- summary_table %>% dplyr::select(-Node)

if (nrow(output_summary_table) == 0) {
    note_str <- paste0(note_str, "\nNone of the input is added to the current reference phylogeny, ",
                       "please choose another reference.")
} else {
    write.tree(names_tree, file = names_tree_path)
    write.tree(taxids_tree, file = taxids_tree_path)
}
cat(note_str, file = output_note_path, append = TRUE)
write.table(output_summary_table, file = summary_file_path, sep = "\t", quote = FALSE, row.names = FALSE)
cat("Done!\n")
